import{O as e,p as t,u as n}from"./chunks/runtime-core.esm-bundler.DoAIpvg0.js";import{t as r}from"./chunks/plugin-vue_export-helper.BIFBW11O.js";const i=JSON.parse(`{"title":"Terminology","description":"","frontmatter":{"title":"Terminology","outline":"deep","head":[["meta",{"property":"og:title","content":"Terminology"}],["meta",{"name":"twitter:title","content":"Terminology"}],["meta",{"property":"og:description","content":"A collection of high-performance JavaScript tools written in Rust"}],["meta",{"name":"twitter:description","content":"A collection of high-performance JavaScript tools written in Rust"}],["meta",{"property":"og:url","content":"https://oxc.rs/docs/learn/terminology.html"}]]},"headers":[],"relativePath":"docs/learn/terminology.md","filePath":"docs/learn/terminology.md"}`);var a={name:`docs/learn/terminology.md`};function o(r,i,a,o,s,c){return e(),n(`div`,null,[...i[0]||=[t(`<h1 id="terminology" tabindex="-1">Terminology <a class="header-anchor" href="#terminology" aria-label="Permalink to “Terminology”">​</a></h1><h2 id="binding" tabindex="-1">Binding <a class="header-anchor" href="#binding" aria-label="Permalink to “Binding”">​</a></h2><p>A value being assigned/bound within a scope.</p><h2 id="binding-type" tabindex="-1">Binding type <a class="header-anchor" href="#binding-type" aria-label="Permalink to “Binding type”">​</a></h2><p>The type of the binding: imported value, assigned value (let/const/var), exported value, func/class declaration, func/method arguments, etc.</p><h2 id="scope" tabindex="-1">Scope <a class="header-anchor" href="#scope" aria-label="Permalink to “Scope”">​</a></h2><p>A block in which bindings can exist. A block is any code surrounded with {}, such as classes, functions, methods, callbacks, if/else, etc. Scopes have a hierarchy, with parents having children (not always), and children belonging to a parent. Bindings in a child shadow those in a parent if they have the same name.</p><h2 id="scope-flags" tabindex="-1">Scope flags <a class="header-anchor" href="#scope-flags" aria-label="Permalink to “Scope flags”">​</a></h2><p>Metadata about the current scope (not inherited hierarchy scope): function, constructor, top-level (program), etc.</p><h2 id="symbol" tabindex="-1">Symbol <a class="header-anchor" href="#symbol" aria-label="Permalink to “Symbol”">​</a></h2><p>A binding wrapper with references to each usage/call site of the bound variable within the current source text. A symbol is assigned an ID in the order they are scanned, and reach reference points to the symbol by that ID.</p><h2 id="symbol-flags" tabindex="-1">Symbol flags <a class="header-anchor" href="#symbol-flags" aria-label="Permalink to “Symbol flags”">​</a></h2><p>Metadata about the symbol/binding.</p><h2 id="reference" tabindex="-1">Reference <a class="header-anchor" href="#reference" aria-label="Permalink to “Reference”">​</a></h2><p>A symbol reference is the usage of a symbol (and in turn a binding), and is assigned an ID in the order they are scanned. Each reference is flagged as read, write, or both.</p><h2 id="span" tabindex="-1">Span <a class="header-anchor" href="#span" aria-label="Permalink to “Span”">​</a></h2><p>The start/end offset of the node within the source text.</p>`,17)]])}var s=r(a,[[`render`,o]]);export{i as __pageData,s as default};
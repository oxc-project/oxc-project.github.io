<!-- This file is auto-generated by tasks/website/src/linter/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/typescript/restrict_template_expressions.rs`;
</script>

# typescript/restrict-template-expressions <Badge type="info" text="Correctness" />

<div class="rule-meta">
<Alert class="default-on" type="success">
<span class="emoji">âœ…</span> This rule is turned on by default when type-aware linting is enabled.
</Alert>
<Alert type="info">
<span class="emoji">ðŸ’­</span> This rule requires <a href="https://oxc.rs/docs/guide/usage/linter/type-aware.html" target="_blank" rel="noreferrer">type information</a>.
</Alert>
<Alert class="fix" type="info">
<span class="emoji">ðŸš§</span> An auto-fix is still under development.
</Alert>
</div>

### What it does

This rule restricts the types allowed in template literal expressions.

### Why is this bad?

Template literals will call toString() on the interpolated values. Some types don't have meaningful string representations (like objects that become "[object Object]") or may not have a toString method at all. This rule helps ensure that only appropriate types are used in template expressions.

### Examples

Examples of **incorrect** code for this rule:

```ts
declare const obj: object;
declare const sym: symbol;
declare const fn: () => void;
declare const arr: unknown[];

// Objects become "[object Object]"
const str1 = `Value: ${obj}`;

// Symbols might not be what you expect
const str2 = `Symbol: ${sym}`;

// Functions become their source code or "[Function]"
const str3 = `Function: ${fn}`;

// Arrays might not format as expected
const str4 = `Array: ${arr}`;

// undefined/null become "undefined"/"null" which might be confusing
declare const maybeValue: string | undefined;
const str5 = `Value: ${maybeValue}`; // Could be "Value: undefined"
```

Examples of **correct** code for this rule:

```ts
declare const str: string;
declare const num: number;
declare const bool: boolean;
declare const obj: object;

// Safe types
const result1 = `String: ${str}`;
const result2 = `Number: ${num}`;
const result3 = `Boolean: ${bool}`;

// Explicit conversions for complex types
const result4 = `Object: ${JSON.stringify(obj)}`;
const result5 = `Array: ${arr.join(", ")}`;

// Handle undefined/null explicitly
declare const maybeValue: string | undefined;
const result6 = `Value: ${maybeValue ?? "N/A"}`;
const result7 = `Value: ${maybeValue || "default"}`;

// Type guards for unknown values
declare const unknown: unknown;
const result8 = typeof unknown === "string" ? `Value: ${unknown}` : "Invalid";
```

## How to use

To **enable** this rule in the CLI or using the config file, you can use:

::: code-group

```bash [CLI]
oxlint --deny typescript/restrict-template-expressions
```

```json [Config (.oxlintrc.json)]
{
  "rules": {
    "typescript/restrict-template-expressions": "error"
  }
}
```

:::

## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>
